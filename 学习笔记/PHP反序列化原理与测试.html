<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1819"/>

<div>
<span><div><font style="font-size: 16pt;"><b>序列化和反序列化</b></font></div><div><span style="font-size: 12pt;"><u><b>序列化和反序列化的作用是实现跨脚本共享数据和节省内存空间</b>。</u></span><font style="font-size: 12pt;">PHP解释器执行完一个脚本后，所有存储变量值、数组、对象的内存都会被释放，无法再被引用这些数据。因此，如果另一个脚本想再次引用这些变量值等数据时，需要这些数据存在于内存时方可引用。但是，内存中这些变量值或者对象一直等到被下一脚本引用，就会浪费内存资源。此时，就可以利用序列化，<b><u>序列化的作用就是将变量值、数组或者对象等数据暂时保存为一个字符串。</u></b>等到要使用时，再利用<b><u>反序列化将字符串转化为原来的数据类型。</u></b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">相关函数</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">serialize($arg)      // 序列化,return string</font></div><div><font style="font-size: 12pt;">unserialize($arg)    // 反序列化,return string</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 16pt;"><b>测试1</b></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12pt;">// 序列化和反序列化的结果</font></span></div><div><font style="font-size: 12pt;">class test{</font></div><div><font style="font-size: 12pt;">    public $a=&quot;a&quot;;</font></div><div><font style="font-size: 12pt;">    protected $b=&quot;b&quot;;</font></div><div><font style="font-size: 12pt;">    private $c=&quot;c&quot;;</font></div><div><font style="font-size: 12pt;">    public function say(){</font></div><div><font style="font-size: 12pt;">        echo &quot;我是类1&quot;;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">echo &quot;&lt;pre&gt;&quot;;</font></div><div><font style="font-size: 12pt;">$test = new test();</font></div><div><font style="font-size: 12pt;">$s = serialize($test);      // 序列化</font></div><div><font style="font-size: 12pt;">var_dump($s);</font></div><div><font style="font-size: 12pt;">$uns = unserialize($s);     // 反序列化</font></div><div><font style="font-size: 12pt;">var_dump($uns);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">结果：</font></div><div><font style="font-size: 12pt;">string(72) &quot;O:4:&quot;test&quot;:3:{s:1:&quot;a&quot;;s:1:&quot;a&quot;;s:4:&quot;*b&quot;;s:1:&quot;b&quot;;s:7:&quot;testc&quot;;s:1:&quot;c&quot;;}&quot;  </font></div><div><font style="font-size: 12pt;">object(test)#2 (3) {</font></div><div><font style="font-size: 12pt;">  [&quot;a&quot;]=&gt;</font></div><div><font style="font-size: 12pt;">  string(1) &quot;a&quot;</font></div><div><font style="font-size: 12pt;">  [&quot;b&quot;:protected]=&gt;</font></div><div><font style="font-size: 12pt;">  string(1) &quot;b&quot;</font></div><div><font style="font-size: 12pt;">  [&quot;c&quot;:&quot;test&quot;:private]=&gt;</font></div><div><font style="font-size: 12pt;">  string(1) &quot;c&quot;</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;">注意：</font></div><div><font style="font-size: 12pt;">（1）protected属性序列化后</font></div><div><font style="font-size: 12pt;"><img src="PHP反序列化原理与测试_files/Image.png" type="image/png" data-filename="Image.png"/></font></div><div><font style="font-size: 12pt;">* 是一个特殊字符，长度为3。</font></div><div><font style="font-size: 12pt;">（2）private属性序列化后</font></div><div><font style="font-size: 12pt;"><img src="PHP反序列化原理与测试_files/Image [1].png" type="image/png" data-filename="Image.png" width="332"/> </font></div><div><font style="font-size: 12pt;">testc 的&quot;test&quot;是类名，7是变量名&quot;c&quot;加类名&quot;test&quot;，以及2个特殊字符 <img src="PHP反序列化原理与测试_files/Image [2].png" type="image/png" data-filename="Image.png"/> ，这个字符无法用键盘打印出来。</font></div><div><font style="font-size: 12pt;">（3）类方法不能被序列化。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 16pt;"><b>测试2</b></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 缺少部分属性反序列化后的结果</font></div><div><font style="font-size: 12pt;">class func{</font></div><div><font style="font-size: 12pt;">    public $a=&quot;class2&quot;;</font></div><div><font style="font-size: 12pt;">    protected $b='123';</font></div><div><font style="font-size: 12pt;">    private $c;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">$s = 'O:4:&quot;func&quot;:1:{s:1:&quot;a&quot;;s:6:&quot;class3&quot;;}';    // 序列化字符串只有一个属性</font></div><div><font style="font-size: 12pt;">$test = unserialize($s);</font></div><div><font style="font-size: 12pt;">var_dump($test);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">结果：</font></div><div><font style="font-size: 12pt;">object(func)#1 (3) {</font></div><div><font style="font-size: 12pt;">  [&quot;a&quot;]=&gt;                                       // a属性的值为序列化字符串中表示的值</font></div><div><font style="font-size: 12pt;">  string(6) &quot;class3&quot;</font></div><div><font style="font-size: 12pt;">  [&quot;b&quot;:protected]=&gt;                             // 补充所属类的属性，值为默认值</font></div><div><font style="font-size: 12pt;">  string(3) &quot;123&quot;</font></div><div><font style="font-size: 12pt;">  [&quot;c&quot;:&quot;func&quot;:private]=&gt;<span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    // private属性同样被补充</span></font></div><div><font style="font-size: 12pt;">  NULL</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 16pt;"><b>测试3</b></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 序列化字符串格式错误的结果</font></div><div><font style="font-size: 12pt;">class func{</font></div><div><font style="font-size: 12pt;">    public $a=&quot;class2&quot;;</font></div><div><font style="font-size: 12pt;">    protected $b='123';</font></div><div><font style="font-size: 12pt;">    private $c;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">$s = 'O:4:&quot;func&quot;:1:{s:1:&quot;a&quot;;s:10:&quot;class3&quot;;}';    // 值的长度改为 10</font></div><div><font style="font-size: 12pt;">$test = unserialize($s);</font></div><div><font style="font-size: 12pt;">var_dump($test);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">结果：</font></div><div><font style="font-size: 12pt;">bool(false)                                      // 反序列化失败，无法得到对象</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 16pt;"><b>__destruct()析构方法</b></font></div><div><font style="font-size: 12pt;">析构方法在对象被销毁时引用，对象被销毁的时机：</font></div><div><font style="font-size: 12pt;">（1）<u><b>对象没有被引用</b></u>，或者说没有一个变量指向对象，为了节省内存空间，垃圾回收机制将回收存储这个对象的内存。</font></div><div><font style="font-size: 12pt;">（2）<b><u>程序结束时，所有的内存都被释放。</u></b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">测试4<br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 程序结束时销毁对象</font></div><div><font style="font-size: 12pt;">class func{</font></div><div><font style="font-size: 12pt;">    public $a=&quot;class2&quot;;</font></div><div><font style="font-size: 12pt;">    public function __destruct(){</font></div><div><font style="font-size: 12pt;">        echo &quot;destruct&quot;;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">$func = new func();</font></div><div><font style="font-size: 12pt;">$s = serialize($func);           // <b>序列化后并不会触发析构方法，因为还有$func引用对象，谨记！！</b></font></div><div><font style="font-size: 12pt;">var_dump($func)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">结果：</font></div><div><font style="font-size: 12pt;">object(func)#1 (1) {</font></div><div><font style="font-size: 12pt;">  [&quot;a&quot;]=&gt;</font></div><div><font style="font-size: 12pt;">  string(6) &quot;class2&quot;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">destruct</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">测试5</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 对象不被引用</font></div><div><font style="font-size: 12pt;">class func{</font></div><div><font style="font-size: 12pt;">    public $a=&quot;class2&quot;;</font></div><div><font style="font-size: 12pt;">    public function __destruct(){</font></div><div><font style="font-size: 12pt;">        echo &quot;destruct&quot;;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12pt;"><br/></font></span></div><div><font style="font-size: 12pt;">$func = new func();</font></div><div><font style="font-size: 12pt;">$func = null;                           // <b>null和空字符串的区别：值为null的变量没有分配内存，值为空字符串的变量有分配内存</b></font></div><div><font style="font-size: 12pt;">echo &quot;已经不存在对象了&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12pt;">结果：</font></span></div><div><font style="font-size: 12pt;">destruct已经不存在对象了                //<b>destruct先被打印，说明程序在结束之前对象已经不存在，然后调用了析构方法；unset()是销毁变量，因此销毁后对象也不存在了，结果与此一致</b></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">测试6</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 排除错误理解</font></div><div><font style="font-size: 12pt;">class func{</font></div><div><font style="font-size: 12pt;">    public $a=&quot;class2&quot;;</font></div><div><font style="font-size: 12pt;">    public function __destruct(){</font></div><div><font style="font-size: 12pt;">        echo &quot;destruct&quot;;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">$func = new func();                           // $func对象</font></div><div><font style="font-size: 12pt;">$s = serialize($func);</font></div><div><font style="font-size: 12pt;">$f = unserialize($s);                         // $f对象</font></div><div><font style="font-size: 12pt;">echo '$func和$f两个对象都存在';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">结果：</font></div><div><font style="font-size: 12pt;">$func和$f两个对象都存在 destruct destruct       // <b>说明两次析构方法是$func和$f对象在程序结束时被销毁的调用</b></font></div></div><div><br/></div></span>
</div></body></html> 